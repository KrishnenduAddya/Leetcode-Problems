// Amazon Google Goldman Sachs

// Binary Search on Answer LC 410

public class Solution {
    public int SplitArray(int[] nums, int k) {
        // The minimum possible largest sum is the maximum element in the array
        // (since no subarray can have a sum smaller than its largest element).
        int low = nums.Max();

        // The maximum possible largest sum is the sum of the entire array
        // (if we don't split at all).
        int high = nums.Sum();

        int minLargestSum = 0;
        while(low <= high)
        {
            int mid = low + (high - low) / 2;

            // Check if it's possible to split the array into <= k subarrays
            // such that no subarray sum exceeds mid
            if(SplitPossible(nums, k, mid))
            {
                // If possible, update result using mid and try to minimize further
                minLargestSum = mid;
                high = mid - 1;
            }
            else // Otherwise, increase the limit
                low = mid + 1;
        }
        return minLargestSum;
    }

    private bool SplitPossible(int[] nums, int k, int mid)
    {
        int subArraySum = 0;
        int subArrayCount = 1; // start with one subarray

        foreach(int num in nums)
        {
            // If adding current number doesn't exceed mid, add it to current subarray
            if(subArraySum + num <= mid)
                subArraySum = subArraySum + num;
            else // Otherwise, start a new subarray
            {
                subArraySum = num;
                subArrayCount++;
            }
        }
        
        // Return true if we can split into at most k subarrays
        return subArrayCount <= k;
    }
}
